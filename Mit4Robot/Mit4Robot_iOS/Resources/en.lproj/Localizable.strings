/*<!-- General -->*/
	"btnCancel"="Cancel";
	"btnClose"="Close";
	"btnBack"="Back";

/*<!-- VCHelpMenu -->*/
	"btnHelpTiles"="Meer info over het speelveld";
	"btnHelpVariables"="Meer info over variabelen";
	"btnHelpFunctions"="Meer info over de functies";
	"btnHelpLanguage"="Meer info over de programmeert(a)al(en)";

/*<!--- VCMainMenu -->*/
	"btnMainStart"="Start";
	"btnMainHelp"="Help";
	"btnMainHighscores"="Highscores";
	"btnMainCredits"="Credits";

/*<!--- VCSelectDifficulty -->*/
	"btnDifficultyEasy"="Easy";
	"btnDifficultyMedium"="Medium";
	"btnDifficultyHard"="Hard";

/*<!--- VCSelectLanguage -->*/
	"btnLanguagePython"="Python";

	/*<!-- VCCredits -->*/
	"txtCredits"="Voor de minor ”Cross-platform Mobile Development” heeft een groep van vijf studenten van Zuyd Hogeschool te Heerlen een serious game ontwikkelt.\nDeze serious game laat de gebruiker van de applicatie een robot programmern.\nHierbij is het de bedoeling dat de robot boodschappen gaat doen bij de betreffende winkels.\n\nCredits:\n\nOpdrachtgever:\nM. van de Laar\n\nDevelopers:\nBjørn Broer\nStef Chappin\nMax Hamulyák\nBert van Montfort\nGuy Spronck\n\nLevel designer:\nBert van Montfort\n\nPublicatiejaar:\nHet publicatiejaar van de MIT4 robot app is 2015.";

/*<!-- VCGame -->*/
	"txtGameHelp"="?";
	"txtGameOptions"="Code opties:";

	"btnGameCodeOpen"="Open file";
	"btnGameCodeSave"="Save file";
	"btnGameCodeShare"="Share code!";
	"btnGameCodeValidate"="Validate code!";
	"btnGameCodeReset"="Reset!";
	"btnGameCodeDelete"="Delete file";

/*<!-- Help texts -->*/
	"txtHelpGeneral"="Dit is de Open- en Meeloopdag app, waarin je kunt leren programmeren in de programmeertalen die gebruikt worden op ZUYD Hogeschool.Het doel van de app is om zelf een robot te programmeren die allerlei opdrachten dient uit te voeren om een level te halen. Opdrachten zijn bijvoorbeeld: Koop een brood bij de bakker. Koop een braadworst bij de slager. Met behulp van simpele instructies, en gebruik van allerlei constructies in je code, kun je de robot deze opdrachten laten uitvoeren.";

	"txtHelpFunctions"="De robot heeft een aantal simpele instructies die uitgevoerd kunnen worden. De volgende instructies zijn beschikbaar: Loop vooruit: de robot beweegt één vakje vooruit. Draai rechtsom: de robot draait zijn gezicht 90 graden naar rechts. Hij loopt hierbij niet van zijn huidige vakje af. Kan: controleer of de robot de richting op kan die jij meegeeft aan de functie, door middel van een variabele. Deze functie wordt gebruikt voor meer complexe constructies in je code.Pak op: de robot pakt een voorwerp dat jij aangeeft in je variabele op, mits: Is bij: controleer of de robot bij de winkel staat die jij in je variabele zet. Aan deze waarde moet voldaan zijn, voor je iets op kunt pakken.";

	"txtHelpVariables"="Variabelen zijn bepaalde objecten met een variabele opslag. Hier kunnen gegevens dynamisch in worden gewijzigd. Zo kunnen wij bijvoorbeeld een variabele genaamd “banaan” aanmaken met als waarde ”groen”. Dat gaat als volgt: banaan = ”groen” Door dit stukje code wordt de waarde ‘groen’ opgeslagen in ”banaan”. Als je hierna de waarde van ”banaan” opvraagt, dan krijg je ‘groen’ terug. De apostrof die voor en achter het woord ‘groen’ staan geven aan dat het om een string gaat. Een string is als het ware een stuk tekst. Door een apostrof voor en achter de tekst te zetten weet het systeem dat het om een stuk tekst gaat. Dit is van groot belang als je gaat programmeren, want zonder de apostrof denk het systeem dat het om een andere variabele gaat. kleur = ”groen” banaan = kleur In het voorbeeld hierboven is een variabele gemaakt genaamd ”kleur” met als waarde ”groen”, een string (een regel tekst). Vervolgens wordt nog een variabele genaamd ”banaan” aangemaakt. Deze krijgt als waarde ”kleur”. Omdat hier geen apostrof omheen staan gaat het dus om de variabele genaamd ”kleur” die eerder is aangemaakt. Hierdoor wordt dus de waarde van ”kleur” in de variabele ”banaan” opgeslagen waardoor de waarde van ”banaan” dus ook ”kleur” wordt. Naast een string kunnen er ook andere dingen worden opgeslagen in variabelen. Je kunt hier bijvoorbeeld ook getallen in opslaan, en hier vervolgens berekeningen mee doen. Je kunt ook de uitkomst van een berekening opslaan in een variabele. getal = 10 In bovenstaand voorbeeld wordt een variabele genaamd ”getal” aangemaakt en wordt de waarde 10 hier in gezet. Het valt je misschien op dat er nu geen apostrof om de waarde 10 heen staan. Hierdoor weet de computer dus dat het om een getal gaat. Je kunt wel apostrof om het getal 10 heen zetten, maar dan wordt het opgeslagen als een stuk tekst (string) waarmee geen berekeningen kunnen worden gedaan. getal = 2 * 2 Bij dit voorbeeld wordt de variabele genaamd ”getal” gevuld met de waarde van ‘2 * 2’ ofwel 2 keer 2, dit is dus 4. Hierdoor krijgt de variabele ”getal” de waarde 4. Zo kan dit ook worden gecombineerd met andere variabelen die een getal bevatten. Je zou dus 'getal * 2' kunnen doen en dan krijg je 8 terug, omdat ”getal” 4 bevat.";

	"txtHelpMap"="Elk level heeft een map, waarover de robot kan bewegen. Om een level succesvol te voltooien, dien je bepaalde opdrachten uit te voeren. Hiervoor gebruik je de robot; de robot kent enkele instructies die je kunt gebruiken om hem te laten bewegen. Op de map zijn verschillende elementen te vinden. Alleen de wegen zijn bewandelbaar; wanneer een robot het commando krijgt om rechtdoor te lopen, wanneer er geen weg is, wordt de code niet uitgevoerd. Op de wegen zijn verschillende winkels te vinden, die je nodig zult hebben om sommige opdrachten te voltooien.";

	"txtHelpRoad"="Zo ziet een weg uit. Wanneer een weg een bocht maakt, dien je de robot eerst te draaien, voor je verder kunt lopen. Aan weerszijdes van de weg kan een winkel liggen.";

	"txtHelpShop"="Zo ziet een winkel uit. Elke winkel heeft een apart plaatje op de muren getekend. Hieraan kun je zien wat voor een sort winkel het is, en wat voor producten deze winkel verkoopt.";

/*<!--- language text strings -->*/
	"txtHelpPython"="Python is een high-level programmeertaal. Dit wil zeggen dat het lezen van deze code erg makkelijk is, en dus makkelijk is om onder de knie te krijgen. We gebruiken op de ZUYD Hogeschool in het eerste jaar ook Python. Hierdoor is de keuze gemaakt om Python als eerste te ondersteunen in deze app.\n\nBegrippenlijst:\n\nitem:\neen item is een object dat je op dient te pakken als onderdeel van een opdracht.\n\nDestination:\neen winkel waar je items kunt oppakken.\n\nConditie:\neen conditie waaraan voldaan moet worden, voor de daarna volgende functie uitgevoerd word.\n\nDe Python taal in deze app bevat de volgende syntax:\n\nmoveForward()\nDit is het commando om de robot vooruit te laten bewegen.\n\nrotateRight()\nDit is het commando om de robot rechtsom te laten draaien.\n\npickUp('item')\nDit is het commando om een item op te pakken.\n\nat('destination')\nDit retourneert of je bij de opgegeven bestemming bent.\n\nleft/right/forward/backward\nControleer of de robot in de opgegeven richting kan bewegen.\n\n[variabelenaam] = [waarde]\nDit maakt een variabele aan met de zelf gedefinieerde variabelenaam, en vult de variabele met de waarde achter het =-teken.\nLet op: er kan alleen gebruikt gemaakt worden van een string, een int of een bool\n\nBijzondere Constructies:\n\nif [conditie]:\nVoert de hierna opgegeven acties (beginnend op een nieuwe regel met een spatie in het begin) uit, mits de conditie voldoet.\n\nelif [conditie]:\nVoert de hierna opgegeven acties (beginnend op een nieuwe regel met een spatie in het begin) uit, mits aan de voorafgaande if of elif niet voldaan is, maar wel aan de conditie in de elif.\nEen elif komt alleen voor na een if, of na een andere elif. Er moet altijd begonnen worden met een if; de if mag maar eenmaal voorkomen als er gebruik gemaakt wordt van elif.\n\nelse:\nVoert de hierna opgegeven acties (beginnend op een nieuwe regel met een spatie in het begin) uit, mits aan alle voorafgaande if en elif niet voldaan word.\n\nwhile [conditie:\nHerhaalt de hierna opgegeven acties (beginnend met een nieuwe regel met een spatie in het begin), totdat de conditie niet meer voldoet.\n\nfor [variabele] in range([startwaarde],[eindwaarde]):\nVoert de hierna opgegeven acties uit, zolang de waarde van je gedefinieerde variabele tussen de gespecificeerde begin- en eindwaarde inzit. Elke actie dient op een aparte regel, beginnend met een spatie te worden geschreven.\n\ndef functienaam():\nAanmaak van een function met een zelf gedefinieerde naam. Elke actie dient op een aparte regel, beginnend met een spatie te worden geschreven. De aanroep van je functie gaat als volgt:\nfunctienaam()\n\n”Nested” constructies:\nEen bijzondere constructie in een andere bijzondere constructie. Hierdoor automatiseer je repetetieve acties, zodat je minder code hoeft te schrijven om een reeks acties uit te voeren.\n\nOperators:\nOperators zijn mutaties die je kunt uitvoeren op variabelen. Keer, delen door, plus en min zijn voorbeelden van operators.\n\nRelational operators:\nDit zijn mutaties, in de vorm van ”=” (gelijk aan), ”<” (kleiner dan) of ”>” (groter dan). Deze moeten gebruikt worden wanneer je twee of meerdere variabelen of waardes met elkaar wilt vergelijken.\n\nLogical operators: Dit zijn mutaties, in de vorm van ”and” (en), ”or” (of) en ”not” (niet). Deze moeten gebruikt worden wanneer er op meerdere condities (of variabalen) moet gecontroleerd worden in je constructies.\n\nVoorrangsregels:\nVoorrangsregels (zoals in de wiskunde) kunnen toegepast worden in je code, om bepaalde controles op condities voor te laten gaan op anderen. Zo kun je bijvoorbeeld eerst controleren of A en B kloppen, voor je dit vergelijks met C. Haakjes werken precies zoals in de wiskunde: alles wat hiertussen staat wordt als eerste uitgevoerd.\n\nVoorrangsregeld Relational operators:\nNa haakjes volgen de ”=”, ”<” en ”>”. Deze hebben geen voorrang op elkaar, en worden dus van links naar rechts uitgevoerd (tenzij ze tussen haakjes instaan).\n\nVoorrangsregels Logical operators:\nNa de relational operators volgt ”not”, dan ”and” en dan ”or”.";

	"txtHelpPascal"="Pascal is een historisch beïnvloedde, imperatieve en procedurale programmeertaal, ontworpen als kleinschalige en efficiënte taal om programming practices te ondersteunen, gebruik maken van gestructureerd programmeren en gestructureerde datastructuren.\n\nBegrippenlijst:\n\nitem:\neen item is een object dat je op dient te pakken als onderdeel van een opdracht.\n\nDestination:\neen winkel waar je items kunt oppakken.\n\nConditie:\neen conditie waaraan voldaan moet worden, voor de daarna volgende functie uitgevoerd word.\n\nDe Pascal taal in deze app bevat de volgende syntax:\n\nmoveForward()\nDit is het commando om de robot vooruit te laten bewegen.\n\nrotateRight()\nDit is het commando om de robot rechtsom te laten draaien.\n\npickUp('item')\nDit is het commando om een item op te pakken.\n\nat('destination')\nDit retourneert of je bij de opgegeven bestemming bent.\n\nleft/right/forward/backward\nControleer of de robot in de opgegeven richting kan bewegen.\n\nvar [variabelenaam] := [waarde]\nDit maakt een variabele aan met de zelf gedefinieerde variabelenaam, en vult de variabele met de waarde achter het =-teken.\nLet op: er kan alleen gebruikt gemaakt worden van een string, een int of een bool\n\nBijzondere Constructies:\n\nif [conditie] then\nbegin\nend;\nOnder de regel met het if-statement komt eerst 'begin'. Daarna volgen de uit te voeren opgegeven acties (beginnend op een nieuwe regel met een spatie in het begin), en wordt het afgesloten met 'end;'.\n\nelse if [conditie]:\nVoert de hierna opgegeven acties (beginnend op een nieuwe regel met een spatie in het begin) uit, mits aan de voorafgaande if of else if niet voldaan is, maar wel aan de conditie in de else if.\nEen else if komt alleen voor na een if, of na een andere else if. Er moet altijd begonnen worden met een if; de if mag maar eenmaal voorkomen als er gebruik gemaakt wordt van else if.\n\nelse:\nVoert de hierna opgegeven acties (beginnend op een nieuwe regel met een spatie in het begin) uit, mits aan alle voorafgaande if en else if niet voldaan word.\n\nwhile [conditie] do\nbegin\nend;\nOnder de regel met het while-statement komt eerst 'begin'. Daarna volgen de uit te voeren opgegeven acties (beginnend op een nieuwe regel met een spatie in het begin), en wordt het afgesloten met 'end;'. De opgegeven acties worden herhaald tot de conditie niet meer voldoet.\n\nfor [variabele]:= [startwaarde] to [eindwaarde] do\nbegin\nend;\nOnder de regel met het for-statement komt eerst 'begin'. Daarna volgen de uit te voeren opgegeven acties (beginnend op een nieuwe regel met een spatie in het begin), en wordt het afgesloten met 'end;'. De opgegeven acties worden herhaald tot de opgegeven variabele niet meer tussen de start- en eindwaarde bevindt. De variabele wordt automatisch met 1 verhoogt.\n\nprocedure [functienaam]();\nbegin\nend;\nAanmaak van een function met een zelf gedefinieerde naam. Onder de regel met de functie declaratie komt eerst 'begin'. Daarna volgen de uit te voeren opgegeven acties (beginnend op een nieuwe regel met een spatie in het begin), en wordt het afgesloten met 'end;'. De aanroep van je functie is als volgt:\n[functienaam]()\n\n”Nested” constructies:\nEen bijzondere constructie in een andere bijzondere constructie. Hierdoor automatiseer je repetetieve acties, zodat je minder code hoeft te schrijven om een reeks acties uit te voeren.\n\nOperators:\nOperators zijn mutaties die je kunt uitvoeren op variabelen. Keer, delen door, plus en min zijn voorbeelden van operators.\nRelational operators:\nDit zijn mutaties, in de vorm van ”=” (gelijk aan), ”<” (kleiner dan) of ”>” (groter dan). Deze moeten gebruikt worden wanneer je twee of meerdere variabelen of waardes met elkaar wilt vergelijken.\n\nLogical operators:\nDit zijn mutaties, in de vorm van ”and” (en), ”or” (of) en ”not” (niet). Deze moeten gebruikt worden wanneer er op meerdere condities (of variabalen) moet gecontroleerd worden in je constructies.\n\nVoorrangsregels:\nVoorrangsregels (zoals in de wiskunde) kunnen toegepast worden in je code, om bepaalde controles op condities voor te laten gaan op anderen. Zo kun je bijvoorbeeld eerst controleren of A en B kloppen, voor je dit vergelijks met C. Haakjes werken precies zoals in de wiskunde: alles wat hiertussen staat wordt als eerste uitgevoerd.\n\nVoorrangsregeld Relational operators:\nNa haakjes volgen de ”=”, ”<” en ”>”. Deze hebben geen voorrang op elkaar, en worden dus van links naar rechts uitgevoerd (tenzij ze tussen haakjes instaan).\n\nVoorrangsregels Logical operators:\nNa de relational operators volgt ”not”, dan ”and” en dan ”or”.";